The User profile info is stored in the stories section. This is to allow it to use the same filtering mechanism.
	But can we just apply the filters to the Users?
	Are there cases where you will want results that are mixed between users and stories?
		Microguides?
		The feed?
		
	Location info?
	
How are we going to slug the various authors with the same names? Linda Johnson and Linda Johnson? 

When you click on an author's name you want to see other things written by that guy. 	



MongoDB

Users:
	slug  : unique title. This is the lowercase and slugged URL cleaned version of the displayed title
	username  : lower case
	
	password
	email
	role
	agreed to EULA
	1099 info
	
	title: the username that is displayed on stories
	
	all story data
	
	public { true, false }
	created
	updated
	
	
	
Tags: 
	tag
	type {tag,city,hood,user}
	parents
	status {pending, approved}
	friends // array of other tags that commonly occur with this tag


// I think we should change it so there is a table for published stories and one for unpublished ones.
// the unpublished ones can have a status telling why they aren't published yet

Stories: 
	slug  : unique title. This is the lowercase and slugged URL cleaned version of the displayed title
	address
	author
	authorSlug
	city
	hood
	phone
	url
	status {working,pending,updating,accepted}
	
	// type {story,user,location?}
	tags
	searchTags  
	text
	title
	created	 //
	updated   // date it was last updated
	
	
Updates:
	story schema +
	parent ID
	

//For each pair of tags we have a degree of co-occurrence	
// this is incremented anytime someone does a filter
// based on the filters
// this is griefable
TagWeb:
hash
tagSet
degree

CacheFilters
hash
tags   // the most popular tags 
updated

we could hash the tags in the set of filters
and create the popular tag set these generate
This can be a cron job
if it misses the hash table then we can generate it on the fly

Story::update( $array( '$pull' => array('searchTags' => $oldTag) ), array( 'authorSlug' => $oldSlug ) );

hi does anyone know why this isn't working: Story::update( $array( '$pull' => array('searchTags' => $oldTag) ), array( 'authorSlug' => $oldSlug ) );  Story is a Model. The DB is mongo. 

hi how do you do the equivalent of: db.posts.update( { author: "oldAuthor"}, { $set: { author : "newAuthor"}, $addToSet: { blah : "foo"} }, false, true );  with a Model?	
	

db.stories.update( { authorSlug:"jed-bob8"}, { $pull: { searchTags : 'jed-bob7'}},false,true);


db.users.update( { username:"jed" }, { $set: { public : 1 } },false,true );
db.users.update( { username:"jed" }, { $set: { role : 'admin' } },false,true );
db.users.update( { username:"misoon burzlaff" }, { $set: { role : 'admin' } },false,true );

db.stories.update( { title:"Big First Image" }, { $set: { layout : 1 } },false,true );

db.stories.update( { title:"Chicken & Waffles " }, { $set: { created : 1331320686 , updated : 1331320686 } },false,true );

db.stories.find({}, {title:1,searchTags:1});


db.posts.find({tags: {$all: ["food", �hello�]}});

now= time()/1000;
rand = (1333769751-1331937596)*Math.random()+1331937596;
db.stories.findOne( { status : 'accepted', updated : { $lte : rand } } ,{title:1,updated:1} )
	


